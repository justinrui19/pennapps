<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Rescuer Interface</title>
    <style>
      html, body { height: 100%; margin: 0; background: #0b0f14; color: #e6f1ff; font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji"; }
      #root { position: fixed; inset: 0; }
      #hud { position: absolute; top: 12px; left: 12px; z-index: 20; background: rgba(15,23,42,0.7); padding: 10px 12px; border-radius: 8px; box-shadow: 0 8px 24px rgba(0,0,0,0.4); }
      .pill { display: inline-block; padding: 3px 8px; margin-right: 6px; border-radius: 999px; background: #1f2937; font-size: 12px; }
      #list { margin-top: 8px; font-size: 12px; line-height: 1.5; max-height: 160px; overflow: auto; }
      #canvas { position: absolute; inset: 0; width: 100%; height: 100%; }
      a { color: #7dd3fc; text-decoration: none; }
    </style>
  </head>
  <body>
    <div id="root">
      <div id="hud">
        <div><strong>Rescuer Interface</strong></div>
        <div id="stats">
          <span class="pill" id="pill-conn">WS: connecting</span>
          <span class="pill" id="pill-dets">Detections: 0</span>
          <span class="pill" id="pill-haz">Hazards: 0</span>
        </div>
        <div id="list"></div>
      </div>
      <canvas id="canvas"></canvas>
    </div>

    <script type="module">
      const ws = new WebSocket(`ws://${location.host}/ws`);
      const pillConn = document.getElementById('pill-conn');
      const pillDets = document.getElementById('pill-dets');
      const pillHaz = document.getElementById('pill-haz');
      const list = document.getElementById('list');
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');

      // Image stream element (offscreen)
      const img = new Image();
      img.decoding = 'sync';

      let state = { detections: {}, hazards: {}, pose: null, path: [], map_points: [] };

      // Stream from proxy
      const params = new URLSearchParams(location.search);
      const stream = params.get('stream') || '';
      const streamURL = stream ? `/video_proxy?url=${encodeURIComponent(stream)}` : '/video_proxy';
      img.src = streamURL;

      function resize() {
        const dpr = window.devicePixelRatio || 1;
        canvas.width = Math.floor(canvas.clientWidth * dpr);
        canvas.height = Math.floor(canvas.clientHeight * dpr);
        draw();
      }
      const ro = new ResizeObserver(() => resize());
      ro.observe(canvas);

      ws.addEventListener('open', () => {
        pillConn.textContent = 'WS: connected';
        pillConn.style.background = '#065f46';
      });
      ws.addEventListener('close', () => {
        pillConn.textContent = 'WS: disconnected';
        pillConn.style.background = '#7f1d1d';
      });
      ws.addEventListener('message', (ev) => {
        const msg = JSON.parse(ev.data);
        if (msg.type === 'state') state = msg.data;
        if (msg.type === 'detections') state.detections = Object.fromEntries(msg.data.map(d => [d.id, d]));
        if (msg.type === 'hazards') state.hazards = Object.fromEntries(msg.data.map(h => [h.id, h]));
        if (msg.type === 'pose') state.pose = msg.data;
        if (msg.type === 'map_points') {
          if (msg.replace) state.map_points = msg.data; else state.map_points.push(...msg.data);
          if (state.map_points.length > 20000) state.map_points = state.map_points.slice(-20000);
        }
        pillDets.textContent = `Detections: ${Object.keys(state.detections).length}`;
        pillHaz.textContent = `Hazards: ${Object.keys(state.hazards).length}`;
        list.innerHTML = [
          ...Object.values(state.detections).map(d => `ðŸ‘¤ ${d.id} [${d.confidence?.toFixed?.(2) ?? ''}] bbox=${d.bbox.map(n => n.toFixed(0)).join(',')}`),
          ...Object.values(state.hazards).map(h => `âš ï¸ ${h.kind} @ ${h.position.map(n => n.toFixed(2)).join(',')}`),
          state.pose ? `ðŸ“ pose t=${state.pose.t.toFixed(2)} p=${state.pose.position.map(n => n.toFixed(2)).join(',')}` : ''
        ].filter(Boolean).join('<br/>');
        draw();
      });

      img.onload = () => draw();

      function draw() {
        const dpr = window.devicePixelRatio || 1;
        const W = canvas.width, H = canvas.height;
        ctx.clearRect(0, 0, W, H);

        // draw video full-screen, object-fit: contain
        if (img.naturalWidth && img.naturalHeight) {
          const iw = img.naturalWidth, ih = img.naturalHeight;
          const scale = Math.min(W / iw, H / ih);
          const vw = iw * scale, vh = ih * scale;
          const vx = (W - vw) / 2, vy = (H - vh) / 2;
          ctx.drawImage(img, vx, vy, vw, vh);

          // draw detections on top in video space
          const scaleX = vw / iw, scaleY = vh / ih;
          ctx.lineWidth = 2 * dpr;
          ctx.font = `${14 * dpr}px system-ui`;
          ctx.textBaseline = 'top';
          for (const d of Object.values(state.detections)) {
            const [x1,y1,x2,y2] = d.bbox;
            const rx1 = vx + x1 * scaleX, ry1 = vy + y1 * scaleY, rw = (x2-x1)*scaleX, rh = (y2-y1)*scaleY;
            ctx.strokeStyle = '#10b981';
            ctx.strokeRect(rx1, ry1, rw, rh);
            const label = `Person ${d.confidence?.toFixed?.(2) ?? ''}`;
            ctx.fillStyle = '#10b981';
            ctx.fillText(label, rx1 + 4*dpr, Math.max(0, ry1 - 16*dpr));
          }
        }

        // minimap on top-right
        const mmW = Math.min(W * 0.28, 360 * dpr);
        const mmH = Math.min(H * 0.28, 240 * dpr);
        const mmX = W - mmW - 16*dpr, mmY = 16*dpr;
        // bg
        ctx.fillStyle = 'rgba(2,6,23,0.65)';
        ctx.fillRect(mmX, mmY, mmW, mmH);
        ctx.strokeStyle = '#334155';
        ctx.lineWidth = 1 * dpr;
        ctx.strokeRect(mmX+0.5*dpr, mmY+0.5*dpr, mmW-1*dpr, mmH-1*dpr);

        // compute bounds from path and map_points
        const pts = state.map_points || [];
        const xs = [...(state.path||[]).map(p=>p[0]), ...pts.map(p=>p[0])];
        const ys = [...(state.path||[]).map(p=>p[1]), ...pts.map(p=>p[1])];
        const minX = Math.min(-5, ...(xs.length?xs:[-5,5]));
        const maxX = Math.max(5, ...(xs.length?xs:[-5,5]));
        const minY = Math.min(-5, ...(ys.length?ys:[-5,5]));
        const maxY = Math.max(5, ...(ys.length?ys:[-5,5]));
        const spanX = Math.max(1e-3, maxX - minX);
        const spanY = Math.max(1e-3, maxY - minY);
        const sx = (mmW - 16*dpr) / spanX;
        const sy = (mmH - 16*dpr) / spanY;
        const ox = mmX + 8*dpr, oy = mmY + 8*dpr;
        function toPix(p) {
          const x = ox + (p[0] - minX) * sx;
          const y = oy + (mmH - 16*dpr) - (p[1] - minY) * sy; // top-down Y invert
          return [x, y];
        }

        // map points (walls): draw sparse points
        if (pts.length) {
          ctx.fillStyle = '#64748b';
          const step = Math.max(1, Math.floor(pts.length / 4000));
          for (let i = 0; i < pts.length; i += step) {
            const [x, y] = toPix(pts[i]);
            ctx.fillRect(x, y, 1.5*dpr, 1.5*dpr);
          }
        }

        // path
        const path = state.path || [];
        if (path.length >= 2) {
          ctx.strokeStyle = '#38bdf8';
          ctx.lineWidth = 2 * dpr;
          ctx.beginPath();
          let [x0, y0] = toPix(path[0]);
          ctx.moveTo(x0, y0);
          for (let i = 1; i < path.length; i++) {
            const [x, y] = toPix(path[i]);
            ctx.lineTo(x, y);
          }
          ctx.stroke();
        }

        // current pose
        if (state.pose && state.pose.position) {
          const [cx, cy] = toPix(state.pose.position);
          ctx.fillStyle = '#10b981';
          ctx.beginPath();
          ctx.arc(cx, cy, 3*dpr, 0, Math.PI*2);
          ctx.fill();
        }
      }
    </script>
  </body>
</html>
